---
title: "计算机是怎么存储数据的"
date: 2021-09-01T15:56:03+08:00
image: "method-draw-image.svg"
description: "存储引擎: 日志结构、面向页面。"
categories:
    - 学习
tags: 
    - ddia
---

## 最简单的数据库

从一个最简单的数据库模型入手，思考我们应该处理的问题。假设我们需要一个 key/value 服务，目前的实现方式为：

1. set: 将一条记录追加到文件末尾。
2. get: 遍历整个文件，直到找到对应的 key/value 对。

每次调用 set 操作，都会向文件末尾追加记录。因此，在调用 get 时，需要从文件末尾开始向前遍历，找到 key 对应的最新的 value。

### 性能分析

该数据库的写入性能很好。因为在写入的时候仅仅是追加写。如果该数据库有着大量的记录，则读取的性能会非常差。开销是 O(n)。

### 改进

#### 索引

我们首先使用哈希表。则最简单的索引策略就是：保留一个内存中的哈希映射，其中每个键都映射到一个数据文件中的字节偏移量，指明了可以找到对应值的位置。

当想要查找一个值时，还需要更新这个哈希表。当想要查找时，则使用这个哈希表保存的偏移量来读取这个值。


#### 减少磁盘消耗

目前我们做的数据库的形式类似于一个 append only 的日志，这不可避免地将消耗所有的磁盘空间。因此一种解决方案是：

将日志分为特定大小的段。当日志增长到特定大小时关闭当前的段文件，并且写入一个新的文件。此时可以将这些旧的段进行压缩：将重复的 key 值消除，只保留最新的值。同时也可以将多个压缩后的段合并，写入一个新的文件。合并完成后，读取请求将使用新的合并的段，因此旧的段文件可以被删除。

> 合并过程中，怎么保证服务的可用性？

在合并过程中，我们并没有去修改旧文件，而是创建了一个新文件。而因为日志一直是追加的，因此，修改旧值也只是添加最后一个文件。因此可以保证没有读写冲突，因此服务是可用的。


### 可能存在的问题

#### 文件格式

使用二进制的格式可以比 csv 格式更快，更简单。先以字节为单位对字符串的长度进行编码，然后使用原始字符串即可，不需要转义。

#### 删除记录

如果要删除一对 key/value，则在添加这条记录时，给这个记录添加一个特殊的标志位。当日志在合并阶段时，如果检测到有这样的一个标志位，则之前这个键的所有数据都会被放弃。get 同理。

#### 崩溃恢复

因为作为索引的哈希表是存在于内存中的，因此如果数据库重启，或者是掉电，则这些数据将丢失。重启之后则需要重建这些记录，消耗的时间可能很长。因此可以以打快照的形式，保存某个时间点之前的所有哈希表。重建时只需要恢复那个时间点之后的哈希记录即可。

数据库也可能随时崩溃，包括在写日志的中途崩溃。可以添加校验和，来检测和忽略日志的这些损坏部分。

#### 并发控制

因为写操作是顺序写附加到日志当中的，因此只能由一个写入线程。已经写入的数据是不变的，因此可以由多个读线程读取。

追加写的好处：

1. 顺序写通常比随机写快得多。
2. 如果段文件是附加的或者不可变的，并发和崩溃恢复会更简单。因为不存在在覆盖的时候崩溃的情况。
3. 合并旧段可以避免数据文件随着时间的推移变得分散。

用哈希做索引的缺点：

1. 哈希表必须能够放进索引。因为不放进索引的话，在磁盘上的哈希映射会产生大量的随机访问，速度变慢。而且需要较好地处理哈希冲突。

2. 范围查询效率不高，只能单独查询某个键。


### 小结

可以看出，这个简单的数据库实现中，有一些特性值得关注。比如极好的写入性能。但同时，也有非常多的值得考虑的问题。其中，索引是相当一部分问题的本源，哈希表的特性使得该设计存在一些问题。因此，索引的设计非常重要。

## SSTables 和 LSM 树

Sorted String Table, 排序字符串表。顾名思义，这里的键值对是有序的。形式类似于 C++ 中的 map，而哈希表则是 C++中的 unordered_map。这里还要求**每个键只在每个合并的段文件中出现一次。**

思考一下使用有序 key 的好处：

1. 合并段简单而且高效。类似于归并排序，只需要取两个合并段中的较小值，写入一个新的段文件即可。这依然保证了段内有序。

> 几个输入段中出现相同的键，则说明有一个是更新的，因此只需要保留最近段的值。

2. 加速搜索。因为有序，因此不再需要在内存中维护所有键的索引。只需要维护各个区间的值，即可进行搜索。这样的索引相较于原先的版本稀疏了很多。

3. 由于读取请求必定要扫描某个区间范围内的多个键值对。因此可以将这些记录分组到块中，并且在将其写入磁盘之前进行压缩。稀疏内存索引的每个条目都指向压缩块的开始处。这样除了可以节省磁盘空间之外，还可以减少 IO 带宽的使用。

现在知道了好处是什么，下面思考一下要如何维护一个有序的 key 集合。答案应该呼之欲出了：红黑树。

> 因为索引在内存中维护，在内存中维护有序结构比在磁盘上容易的多。

一个工作流程：

- 写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为**内存表（memtable）**。
- 当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。这可以高效地完成，因为树已经维护了按键排序的键值对。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。
- 为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字。
- 有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。

> 这个方案效果很好。它只会遇到一个问题：**如果数据库崩溃，则最近的写入（在内存表中，但尚未写入磁盘）将丢失。** 为了避免这个问题，我们可以在磁盘上保存一个单独的日志，每个写入都会立即被附加到磁盘上，就像在前一节中一样。该日志不是按排序顺序，但这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当内存表写出到SSTable时，相应的日志都可以被丢弃。

### 基于 SSTables 的 LSM 树

>  LSM：Log-Structured Merge Tree

上面描述的过程实际上就是 LSM 树的原理。基于这种原理的存储引擎被称为 LSM 存储引擎。

分析读写性能：

- 尽管使用了 SSTable，但在进行查询不存在的 Key 时，LSM 可能会很慢：需要检查内存表（搜索红黑树），并且读取对应区间内的每个段（一直回到最老的），才能确定键不存在。
- 数据有序存储，可以高效执行范围查询

- 写是顺序写，速度依然快。

为了加速查询不存在的 key 的过程，可以使用布隆过滤器。**布隆过滤器** 说不存在的就一定不存在。虽然有一定几率的误判，但还是能够加速这个查询的过程。

> 疑惑：虽然写的速度很快，但是这种方式可以采用多线程写吗？这里全都没有提到。

更多的相关资料见[知乎专栏](https://zhuanlan.zhihu.com/p/181498475)

## B树

B 树也是保持数据有序的结构，允许高效的范围查询以及键值查询（O(n)）。B 树与SSTables的区别在于，SSTables的段的大小是可变的，而B树将数据库划分成了固定大小的块或者页面。

> 这样的结构也很容易理解：类比于 OS 的内存分段和分页机制。B树的一个块一般来说是 4KB，很好地结合了 OS 的分页机制。

每个页面都可以用地址或者位置来标识，这允许一个页面引用另一个页面。在 64 位机中，需要 8 个字节来表示一个页面。（或许不需要，因为按照内存对齐的原则，可以减少几个 bit 的存储量）

![**使用B树索引查找一个键**](fig3-6.png)

在上图中，这个 B 树的分支因子是 6。表示每个节点都有 6 个子节点（一段区间被 5 个点划分，划分成了 6 段）。

这里不再详细描述怎么在插入、删除操作下维护 B 树的平衡。

### 可靠的B树

B 树的底层写操作是用新数据覆盖磁盘上的页面。假设这个覆盖操作不改变页面的位置，则所有**引用了这个页面**的页面都能够看到这个覆盖操作。

但这也带来了问题：在插入数据时如果导致了拆分页面的操作，则需要写入已经拆分的两个页面，并且覆盖父页面来更新对这两个子页面的引用。如果系统在此时崩溃，则会导致这个引用没有被修改成功（子页面成了孤儿页面，没有任何父页面引用他）

为了能够容上面的错，可以维护一个 redo 日志（预写式日志，Write-Ahead-Log）。用于崩溃后的数据恢复。

### B 树优化

由于B树已经存在了这么久，许多优化已经发展了多年，这并不奇怪。仅举几例：

- 一些数据库（如LMDB）使用**写时复制**方案【21】，而不是覆盖页面并维护WAL进行崩溃恢复。修改的页面被写入到不同的位置，并且树中的父页面的新版本被创建，指向新的位置。这种方法对于并发控制也很有用，我们将在“[快照隔离和可重复读](https://vonng.github.io/ddia/#/ch7?id=快照隔离和可重复读)”中看到。
- 我们可以通过不存储整个键，而是缩短其大小，来节省页面空间。特别是在树内部的页面上，键只需要提供足够的信息来充当键范围之间的边界。在页面中包含更多的键允许树具有更高的分支因子，因此更少的层次。
- 通常，页面可以放置在磁盘上的任何位置；没有什么要求附近的键放在页面附近的磁盘上。如果查询需要按照排序顺序扫描大部分关键字范围，那么这种按页面存储的布局可能会效率低下，因为每个读取的页面都可能需要磁盘寻道。因此，许多B树实现尝试布局树，使得叶子页面按顺序出现在磁盘上。但是，随着树的增长，维持这个顺序是很困难的。相比之下，由于LSM树在合并过程中一次又一次地重写存储的大部分，所以它们更容易使顺序键在磁盘上彼此靠近。
- 额外的指针已添加到树中。例如，每个叶子页面可以在左边和右边具有对其兄弟页面的引用，这允许不跳回父页面就能顺序扫描。
- B树的变体如分形树【22】借用一些日志结构的思想来减少磁盘寻道（而且它们与分形无关）。

## 体会

DDIA 相当于只是一个综述，这本书将单体数据库、分布式数据库以及对于这些数据的操作流程大致过了一遍。每一个细小的点如果想要深入的话都需要相当大的精力。还需继续努力！

## 参考资料

[Designing Data-Intensive Applications](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/)

[ddia 社区中文翻译版](https://vonng.github.io/ddia/#/ch3)

